<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="README_8md" kind="file" language="Markdown">
    <compoundname>README.md</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">##<sp/>LameUI<sp/>-<sp/>a<sp/>lightweight<sp/>GUI<sp/>library<sp/>for<sp/>embedded<sp/>systems</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>What?</highlight></codeline>
<codeline><highlight class="normal">LameUI<sp/>is<sp/>a<sp/>super<sp/>simple,<sp/>platform<sp/>independent<sp/>UI<sp/>library<sp/>with<sp/>lots<sp/>of<sp/>limitations,<sp/>designed<sp/>for<sp/>embedded<sp/>systems<sp/>with<sp/>low<sp/>resources.<sp/>It&apos;s<sp/>under<sp/>active<sp/>development<sp/>and<sp/>I&apos;m<sp/>trying<sp/>to<sp/>add<sp/>more<sp/>features.<sp/>Two<sp/>important<sp/>goals<sp/>of<sp/>LameUI<sp/>are:</highlight></codeline>
<codeline><highlight class="normal"><sp/>-<sp/>Be<sp/>lightweight</highlight></codeline>
<codeline><highlight class="normal"><sp/>-<sp/>Use<sp/>minimum<sp/>number<sp/>of<sp/>files</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Why?</highlight></codeline>
<codeline><highlight class="normal">Main<sp/>reason<sp/>-<sp/>to<sp/>challenge<sp/>my<sp/>skills<sp/>and<sp/>learn<sp/>new<sp/>things.<sp/>It<sp/>was<sp/>started<sp/>as<sp/>a<sp/>pastime<sp/>project<sp/>during<sp/>the<sp/>first<sp/>covid-19<sp/>lock-down<sp/>and<sp/>soon<sp/>enough<sp/>I<sp/>abandoned<sp/>it<sp/>in<sp/>an<sp/>incomplete<sp/>state<sp/>as<sp/>I<sp/>lost<sp/>interest.<sp/>After<sp/>4<sp/>months<sp/>I<sp/>came<sp/>back<sp/>to<sp/>it<sp/>with<sp/>a<sp/>goal<sp/>to<sp/>at<sp/>least<sp/>make<sp/>it<sp/>work<sp/>once.<sp/>Future<sp/>of<sp/>this<sp/>project<sp/>is<sp/>uncertain,<sp/>but<sp/>as<sp/>long<sp/>as<sp/>it<sp/>feels<sp/>challenging,<sp/>I&apos;ll<sp/>keep<sp/>adding/fixing<sp/>stuffs.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Who?</highlight></codeline>
<codeline><highlight class="normal">**Who<sp/>will<sp/>use<sp/>it?**<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">Probably<sp/>no<sp/>one.<sp/>Unless<sp/>you<sp/>need<sp/>a<sp/>very<sp/>simple<sp/>and<sp/>very<sp/>lightweight<sp/>UI<sp/>library.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**Who<sp/>is/are<sp/>developing<sp/>it?**<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">I,<sp/>alone.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>API<sp/></highlight></codeline>
<codeline><highlight class="normal">API<sp/>Documentation:<sp/>https://abhra0897.github.io/LameUI/<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">*Note:<sp/>Documentation<sp/>is<sp/>work<sp/>in<sp/>progress.*</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Demo:</highlight></codeline>
<codeline><highlight class="normal">This<sp/>is<sp/>a<sp/>demo<sp/>of<sp/>LameUI<sp/>running<sp/>on<sp/>a<sp/>simulator<sp/>I<sp/>made<sp/>with<sp/>OpenGL<sp/>so<sp/>I<sp/>can<sp/>test<sp/>it<sp/>without<sp/>needing<sp/>to<sp/>flash<sp/>the<sp/>microcontroller<sp/>every<sp/>time.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">simulator:<sp/>https://github.com/abhra0897/LameUI_simulation</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">![Screen<sp/>shots](./LameUI_demo1_combined.png)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>UI<sp/>Widgets</highlight></codeline>
<codeline><highlight class="normal">Following<sp/>UI<sp/>widgets<sp/>are<sp/>implemented<sp/>so<sp/>far:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>Label</highlight></codeline>
<codeline><highlight class="normal">2.<sp/>Line<sp/>chart</highlight></codeline>
<codeline><highlight class="normal">3.<sp/>Button</highlight></codeline>
<codeline><highlight class="normal">4.<sp/>Switch</highlight></codeline>
<codeline><highlight class="normal">5.<sp/>Checkbox</highlight></codeline>
<codeline><highlight class="normal">6.<sp/>Slider</highlight></codeline>
<codeline><highlight class="normal">7.<sp/>List</highlight></codeline>
<codeline><highlight class="normal">8.<sp/>Button<sp/>grid</highlight></codeline>
<codeline><highlight class="normal">9.<sp/>Keyboard</highlight></codeline>
<codeline><highlight class="normal">10.<sp/>Textbox</highlight></codeline>
<codeline><highlight class="normal">11.<sp/>Panel</highlight></codeline>
<codeline><highlight class="normal">12.<sp/>Scene</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Usage</highlight></codeline>
<codeline><highlight class="normal">LameUI<sp/>needs<sp/>3<sp/>callback<sp/>functions<sp/>from<sp/>user<sp/>to<sp/>draw<sp/>on<sp/>display<sp/>and<sp/>read<sp/>inputs.<sp/><sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>`draw_pixels_area_cb`<sp/>to<sp/>*Display<sp/>Output*.<sp/><sp/>(**Mandatory**)</highlight></codeline>
<codeline><highlight class="normal">2.<sp/>`render_complete_cb`<sp/>to<sp/>*Display<sp/>Output*.<sp/><sp/><sp/>(**Optional**)</highlight></codeline>
<codeline><highlight class="normal">3.<sp/>`read_touch_input_cb`<sp/>to<sp/>*Read<sp/>Inputs*.<sp/><sp/><sp/><sp/><sp/>(**Optional**)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Display<sp/>Output</highlight></codeline>
<codeline><highlight class="normal">**1.<sp/>`draw_pixels_area_cb`**<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">Drawing<sp/>to<sp/>display<sp/>is<sp/>done<sp/>by<sp/>callback<sp/>functions<sp/>provided<sp/>by<sp/>the<sp/>user.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```C</highlight></codeline>
<codeline><highlight class="normal">void<sp/>lui_dispdrv_set_draw_pixels_area_cb(lui_dispdrv_t*<sp/>dispdrv,<sp/>void<sp/>(*draw_pixels_area_cb)(uint16_t<sp/>x,<sp/>uint16_t<sp/>y,<sp/>uint16_t<sp/>w,<sp/>uint16_t<sp/>h,<sp/>uint16_t<sp/>color));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**2.<sp/>`render_complete_cb`**<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">LameUI<sp/>has<sp/>no<sp/>frame<sp/>buffer<sp/>of<sp/>its<sp/>own.<sp/>Because<sp/>it&apos;s<sp/>mainly<sp/>targeted<sp/>towards<sp/>MCUs<sp/>with<sp/>low<sp/>RAM.<sp/>As<sp/>a<sp/>result,<sp/>user<sp/>need<sp/>to<sp/>manage<sp/>buffering<sp/>if<sp/>they<sp/>need<sp/>to.<sp/>Sometimes<sp/>buffering,<sp/>and<sp/>then<sp/>flushing<sp/>the<sp/>entire<sp/>buffer<sp/>is<sp/>faster<sp/>than<sp/>writing<sp/>individual<sp/>pixels<sp/>each<sp/>time.<sp/><sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">That&apos;s<sp/>why<sp/>LameUI<sp/>calls<sp/>`void<sp/>(*render_complete_cb)();`<sp/>when<sp/>rendering<sp/>is<sp/>complete,<sp/>given<sp/>that<sp/>user<sp/>provided<sp/>the<sp/>callback<sp/>function.<sp/>In<sp/>that<sp/>callback<sp/>function,<sp/>user<sp/>should<sp/>flush<sp/>the<sp/>buffer.<sp/>This<sp/>is<sp/>useful<sp/>when<sp/>user<sp/>is<sp/>buffering<sp/>the<sp/>draw<sp/>calls.<sp/><sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>setting<sp/>the<sp/>callback<sp/>function,<sp/>this<sp/>function<sp/>is<sp/>used:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```C</highlight></codeline>
<codeline><highlight class="normal">void<sp/>lui_dispdrv_set_render_complete_cb(lui_dispdrv_t*<sp/>dispdrv,<sp/>void<sp/>(*render_complete_cb)());</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note:<sp/>Commonly<sp/>available<sp/>lcd<sp/>displays<sp/>that<sp/>we<sp/>use<sp/>with<sp/>microcontroller<sp/>have<sp/>built-in<sp/>GRAM,<sp/>hence,<sp/>the<sp/>`render_complete_cb()`<sp/>is<sp/>not<sp/>mandatory<sp/>for<sp/>them.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Read<sp/>Inputs</highlight></codeline>
<codeline><highlight class="normal">**3.<sp/>`read_touch_input_cb`**<sp/><sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">LameUI<sp/>now<sp/>only<sp/>supports<sp/>touch<sp/>input.<sp/>Support<sp/>for<sp/>D-Pad<sp/>/<sp/>Rotary<sp/>encoder<sp/>is<sp/>in<sp/>my<sp/>mind,<sp/>but<sp/>that&apos;s<sp/>not<sp/>the<sp/>priority<sp/>for<sp/>now.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```C</highlight></codeline>
<codeline><highlight class="normal">void<sp/>lui_touch_inputdev_set_read_input_cb(lui_touch_input_dev_t*<sp/>touch_inputdev,<sp/>void<sp/>(*read_touch_input_cb)(lui_touch_input_data_t*<sp/>touch_inputdata));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Quick<sp/>Start</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**[<sp/>Part<sp/>1<sp/>]**</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>is<sp/>a<sp/>very<sp/>simple<sp/>example<sp/>using<sp/>TFT_eSPI<sp/>library<sp/>on<sp/>Arduino<sp/>framework.<sp/>In<sp/>this<sp/>example<sp/>we<sp/>will<sp/>only<sp/>see<sp/>how<sp/>to<sp/>register<sp/>a<sp/>display<sp/>driver<sp/>and<sp/>a<sp/>touch<sp/>input<sp/>device.<sp/>No<sp/>UI<sp/>widgets<sp/>are<sp/>added<sp/>here.<sp/>For<sp/>a<sp/>detailed<sp/>example,<sp/>see<sp/>next<sp/>part.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```C</highlight></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>example<sp/>uses<sp/>TFT_eSPI<sp/>library<sp/>on<sp/>Arduino<sp/>framework</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Hardware:<sp/>[MCU<sp/>=<sp/>ESP32,<sp/>Display:<sp/>ILI9341,<sp/>Touch<sp/>IC<sp/>=<sp/>XPT2046]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;TFT_eSPI.h&gt;<sp/>//<sp/>Graphics<sp/>and<sp/>font<sp/>library<sp/>for<sp/>ILI9341<sp/>driver<sp/>chip</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;SPI.h&gt;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>...<sp/>[<sp/>Include<sp/>LameUI<sp/>library<sp/>and<sp/>other<sp/>required<sp/>headers<sp/>too]<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TFT_eSPI<sp/>tft<sp/>=<sp/>TFT_eSPI();<sp/><sp/>//<sp/>Invoke<sp/>library</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>lui_memory[4000];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>draw_pixels_area_cb(uint16_t<sp/>x,<sp/>uint16_t<sp/>y,<sp/>uint16_t<sp/>w,<sp/>uint16_t<sp/>h,<sp/>uint16_t<sp/>color)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tft.fillRect(x,<sp/>y,<sp/>w,<sp/>h,<sp/>color);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">void<sp/>read_touch_input_cb(lui_touch_input_data_t*<sp/>inputdata)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uint16_t<sp/>x<sp/>=<sp/>0,<sp/>y<sp/>=<sp/>0;<sp/>//<sp/>To<sp/>store<sp/>the<sp/>touch<sp/>coordinates</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Pressed<sp/>will<sp/>be<sp/>set<sp/>true<sp/>is<sp/>there<sp/>is<sp/>a<sp/>valid<sp/>touch<sp/>on<sp/>the<sp/>screen</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>pressed<sp/>=<sp/>tft.getTouch(&amp;x,<sp/>&amp;y);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inputdata-&gt;is_pressed<sp/>=<sp/>pressed;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pressed)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inputdata-&gt;x<sp/>=<sp/>x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inputdata-&gt;y<sp/>=<sp/>y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inputdata-&gt;x<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inputdata-&gt;y<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>setup(void)<sp/></highlight></codeline>
<codeline><highlight class="normal">{<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Initilaize<sp/>tft</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tft.init();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tft.setTouch(touch_cal_data);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Initialize<sp/>LameUI<sp/>with<sp/>some<sp/>memory</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_init(lui_memory,<sp/>sizeof(lui_memory));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Create<sp/>a<sp/>display<sp/>driver<sp/>object</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_dispdrv_t*<sp/>display_driver<sp/>=<sp/>lui_dispdrv_create();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_dispdrv_register(display_driver);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_dispdrv_set_resolution(display_driver,<sp/>240,<sp/>320);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_dispdrv_set_draw_pixels_area_cb(display_driver,<sp/>draw_pixels_area_cb);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_dispdrv_set_render_complete_cb(display_driver,<sp/>NULL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Create<sp/>touch<sp/>input<sp/>device</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_touch_input_dev_t*<sp/>input_device<sp/>=<sp/>lui_touch_inputdev_create();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_touch_inputdev_register(input_device);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_touch_inputdev_set_read_input_cb(input_device,<sp/>read_touch_input_cb);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>...<sp/>[Add<sp/>scene<sp/>(mandatory)<sp/>and<sp/>other<sp/>widgets]<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>loop()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Must<sp/>update<sp/>the<sp/>UI<sp/>periodically</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_update();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>...<sp/>[Do<sp/>other<sp/>stuffs]<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">**[<sp/>Part<sp/>2<sp/>]**</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>is<sp/>a<sp/>more<sp/>detailed<sp/>LameUI<sp/>example<sp/>code.<sp/>It<sp/>looks<sp/>big,<sp/>but<sp/>that&apos;s<sp/>only<sp/>because<sp/>multiple<sp/>ways<sp/>of<sp/>handling<sp/>draw<sp/>calls<sp/>are<sp/>shown<sp/>here.<sp/>Implementation<sp/>of<sp/>`my_draw_pixels_cb()`<sp/>function<sp/>can<sp/>be<sp/>simplified<sp/>as<sp/>per<sp/>user&apos;s<sp/>need.<sp/>Also,<sp/>`my_render_cmplt_cb()`<sp/>is<sp/>optional<sp/>and<sp/>can<sp/>be<sp/>omitted<sp/>if<sp/>not<sp/>needed.<sp/>The<sp/>example<sp/>code<sp/>itself<sp/>is<sp/>pretty<sp/>simple<sp/>and<sp/>well<sp/>commented.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```C</highlight></codeline>
<codeline><highlight class="normal">#include&lt;stdio.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;LameUI/lame_ui.h&quot;</highlight></codeline>
<codeline><highlight class="normal">//...<sp/>other<sp/>required<sp/>includes<sp/>....</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#define<sp/>HOR_RES<sp/><sp/><sp/><sp/>320</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>VERT_RES<sp/><sp/><sp/>240</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>[Mandatory]<sp/>LameUI<sp/>memory.<sp/>Here<sp/>we<sp/>are<sp/>giving<sp/>it<sp/>2KB<sp/>to<sp/>work<sp/>with.</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>lameui_memory[2000];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>[Optional]<sp/>LameUI<sp/>does<sp/>NOT<sp/>use<sp/>display<sp/>buffer.<sp/>This<sp/>is<sp/>used<sp/>only<sp/>if<sp/>user<sp/>wants<sp/></highlight></codeline>
<codeline><highlight class="normal">//<sp/>to<sp/>buffer<sp/>on<sp/>their<sp/>own.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Uncomment<sp/>below<sp/>line<sp/>to<sp/>enable<sp/>display<sp/>buffering.<sp/>Buffering<sp/>is<sp/>handled<sp/>by<sp/>user<sp/>and<sp/>NOT<sp/>by<sp/>LameUI.</highlight></codeline>
<codeline><highlight class="normal">//#define<sp/>USE_BUFFERING</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>USE_BUFERING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#define<sp/>DISPLAY_BUFF_SIZE<sp/><sp/><sp/><sp/>(HOR_RES<sp/>*<sp/>VERT_RES)<sp/><sp/><sp/>//<sp/>Only<sp/>full<sp/>screen<sp/>buffer<sp/>is<sp/>possible<sp/>(no<sp/>partial<sp/>buffer)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uint16_t<sp/>display_buffer[DISPLAY_BUFF_SIZE];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>display_buff_counter<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//-----------<sp/>callback<sp/>function<sp/>prototypes<sp/>------------</highlight></codeline>
<codeline><highlight class="normal">void<sp/>my_draw_pixels_cb<sp/>(uint16_t<sp/>x,<sp/>uint16_t<sp/>y,<sp/>uint16_t<sp/>w,<sp/>uint16_t<sp/>h,<sp/>uint16_t<sp/>color);</highlight></codeline>
<codeline><highlight class="normal">void<sp/>my_render_cmplt_cb();</highlight></codeline>
<codeline><highlight class="normal">void<sp/>my_input_read_cb<sp/>(lui_touch_input_data_t<sp/>*input);</highlight></codeline>
<codeline><highlight class="normal">void<sp/>button_1_cb(lui_obj_t*<sp/>button_obj);</highlight></codeline>
<codeline><highlight class="normal">//-----------------------------------------------------</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>[Mandatory]<sp/>At<sp/>the<sp/>starting,<sp/>initialize<sp/>LameUI<sp/>with<sp/>some<sp/>working<sp/>memory.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>This<sp/>memory<sp/>is<sp/>used<sp/>to<sp/>create<sp/>objects</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_init(lameui_memory,<sp/>sizeof(lameui_memory));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//----------------------------------------------------------</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//[Mandatory]<sp/>creating<sp/>display<sp/>driver<sp/>object</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_dispdrv_t<sp/>*my_display_driver<sp/>=<sp/>lui_dispdrv_create();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_dispdrv_register(my_display_driver);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_dispdrv_set_resolution(my_display_driver,<sp/>HOR_RES,<sp/>VERT_RES);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_dispdrv_set_draw_pixels_area_cb(my_display_driver,<sp/>my_draw_pixels_cb);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Setting<sp/>render<sp/>complete<sp/>callback<sp/>is<sp/>optional.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Only<sp/>needed<sp/>if<sp/>user<sp/>is<sp/>buffering<sp/>the<sp/>draw<sp/>calls.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifdef<sp/>USE_BUFERING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lui_dispdrv_set_render_complete_cb(my_display_driver,<sp/>my_render_cmplt_cb);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//[Optional]<sp/>creating<sp/>input<sp/>device<sp/>object</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_touch_input_dev_t<sp/>*my_input_device<sp/>=<sp/>lui_touch_inputdev_create();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_touch_inputdev_register(my_input_device);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_touch_inputdev_set_read_input_cb(my_input_device,<sp/>my_input_read_cb);<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//----------------------------------------------------------</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//[Mandatory]<sp/>create<sp/>and<sp/>add<sp/>a<sp/>scene</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>There<sp/>must<sp/>be<sp/>at<sp/>least<sp/>one<sp/>scene.<sp/>It<sp/>is<sp/>at<sp/>the<sp/>top<sp/>of<sp/>the<sp/>hierarchy.<sp/>All<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>other<sp/>objects<sp/>will<sp/>be<sp/>under<sp/>the<sp/>hierarchy<sp/>of<sp/>a<sp/>scene.<sp/>There<sp/>can<sp/>be<sp/>multiple<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>scenes.<sp/>A<sp/>particular<sp/>object<sp/>can<sp/>be<sp/>under<sp/>only<sp/>one<sp/>scene<sp/>at<sp/>a<sp/>time.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_obj_t*<sp/>scene_1<sp/>=<sp/>lui_scene_create();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>[Mandatory]<sp/>A<sp/>scene<sp/>must<sp/>be<sp/>set<sp/>as<sp/>active<sp/>scene.<sp/>Only<sp/>the<sp/>active<sp/>scene</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>is<sp/>rendered.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_scene_set_active(scene_1);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Create<sp/>a<sp/>label</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_obj_t*<sp/>label_1<sp/>=<sp/>lui_label_create();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>[Mandatory]<sp/>An<sp/>object<sp/>must<sp/>have<sp/>a<sp/>parent<sp/>which<sp/>is<sp/>either<sp/>a<sp/>`scene`<sp/>or<sp/>a<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>descendent<sp/>of<sp/>`scene`.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_object_add_to_parent(label_1,<sp/>scene_1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_object_set_position(label_1,<sp/>5,<sp/>50);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_label_set_text(label_1,<sp/>&quot;This<sp/>is<sp/>Label<sp/>1.<sp/>Below<sp/>is<sp/>Button<sp/>1&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Create<sp/>a<sp/>button</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_obj_t*<sp/>button_1<sp/>=<sp/>lui_button_create();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>[Mandatory]<sp/>Add<sp/>a<sp/>parent</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_object_add_to_parent(button_1,<sp/>scene_1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_object_set_area(button_1,<sp/>110,<sp/>40);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_object_set_position(button_1,<sp/>65,<sp/>100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_button_set_label_text(button_1,<sp/>&quot;Button<sp/>1&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lui_object_set_callback(button_1,<sp/>button_1_cb);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>LameUI<sp/>has<sp/>no<sp/>built-in<sp/>timer.<sp/>So,<sp/>update<sp/>LameUI<sp/>periodically.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>lui_update()<sp/>function<sp/>reads<sp/>inputs,<sp/>checks<sp/>if<sp/>anything<sp/>needs<sp/>to<sp/>be<sp/>drawn,<sp/>and<sp/>fires<sp/>callbacks<sp/>if<sp/>and<sp/>when<sp/>needed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lui_update();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sleep_ms(30);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//-----------<sp/>callback<sp/>function<sp/>definitions<sp/>------------</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>my_draw_pixels_cb<sp/>(uint16_t<sp/>x,<sp/>uint16_t<sp/>y,<sp/>uint16_t<sp/>width,<sp/>uint16_t<sp/>height,<sp/>uint16_t<sp/>color)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Assuming<sp/>user<sp/>has<sp/>at<sp/>least<sp/>one<sp/>of<sp/>these<sp/>functions:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>1.<sp/>display_put_pixel(x,<sp/>y,<sp/>color);<sp/><sp/><sp/><sp/>//<sp/>Draw<sp/>a<sp/>single<sp/>pixel</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>2.<sp/>display_put_pixels(x1,<sp/>y1,<sp/>x2,<sp/>y2,<sp/>color)<sp/><sp/><sp/><sp/>//<sp/>Fill<sp/>an<sp/>area<sp/>with<sp/>same<sp/>color</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>3.<sp/>display_fill(color_buffer,<sp/>x1,<sp/>y1,<sp/>x2,<sp/>y2);<sp/><sp/><sp/><sp/>//<sp/>Fill<sp/>an<sp/>area<sp/>with<sp/>different<sp/>colors<sp/>from<sp/>a<sp/>buffer</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifdef<sp/>USE_BUFERING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>When<sp/>using<sp/>buffering,<sp/>we&apos;ll<sp/>put<sp/>pixels<sp/>inside<sp/>a<sp/>full-screen<sp/>buffer.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Fill<sp/>the<sp/>display<sp/>with<sp/>buffer<sp/>when<sp/>either<sp/>the<sp/>buffer<sp/>is<sp/>full,<sp/>or<sp/>when</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>the<sp/>`render_complete`<sp/>callback<sp/>is<sp/>fired<sp/>by<sp/>LameUI.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint16_t<sp/>temp_x<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint16_t<sp/>temp_y<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Prepare<sp/>the<sp/>display<sp/>buffer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>After<sp/>the<sp/>loop<sp/>ends,<sp/>the<sp/>prepared<sp/>buffer<sp/>is<sp/>flushed</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(temp_y<sp/>=<sp/>y;<sp/>temp_y<sp/>&lt;=<sp/>y<sp/>+<sp/>height<sp/>-<sp/>1;<sp/>temp_y++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(temp_x<sp/>=<sp/>x;<sp/>temp_x<sp/>&lt;=<sp/>x<sp/>+<sp/>width<sp/>-<sp/>1;<sp/>temp_x++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>display_buffer[HOR_RES<sp/>*<sp/>y<sp/>+<sp/>x]<sp/>=<sp/>color;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>increase<sp/>the<sp/>buffer<sp/>counter</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>display_buff_counter++;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>If<sp/>size<sp/>reached<sp/>max<sp/>buffer<sp/>size,<sp/>flush<sp/>it<sp/>now</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(display_buff_counter<sp/>&gt;=<sp/>DISPLAY_BUFF_SIZE)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>display_fill(display_buffer,<sp/>0,<sp/>0,<sp/>HOR_RES,<sp/>VERT_RES)<sp/><sp/><sp/>//<sp/>Filling<sp/>an<sp/>area<sp/>with<sp/>multiple<sp/>colors<sp/>from<sp/>a<sp/>buffer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>display_buff_counter<sp/>=<sp/>0;<sp/>//reset<sp/>the<sp/>counter</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>When<sp/>not<sp/>using<sp/>buffering,<sp/>directly<sp/>draw<sp/>those<sp/>pixels.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>There<sp/>are<sp/>2<sp/>ways.<sp/>Uncomment<sp/>the<sp/>method<sp/>user<sp/>wants<sp/>to<sp/>use.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//------------------<sp/>[<sp/>Method<sp/>1]<sp/>-----------------------------------</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Draw<sp/>pixels<sp/>one<sp/>by<sp/>1.<sp/>This<sp/>is<sp/>the<sp/>easiest<sp/>way<sp/>to<sp/>implement,<sp/>but<sp/>also<sp/>slow.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//------------------------------------------------------------------</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>for<sp/>(uint16_t<sp/>h<sp/>=<sp/>0;<sp/>h<sp/>&lt;<sp/>height;<sp/>h++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>for<sp/>(uint16_t<sp/>w<sp/>=<sp/>0;<sp/>w<sp/>&lt;<sp/>width;<sp/>w++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/>display_put_pixel(x,<sp/>y,<sp/>color);<sp/><sp/><sp/><sp/>//<sp/>Filling<sp/>a<sp/>single<sp/>pixel<sp/>with<sp/>a<sp/>color</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//------------------<sp/>[<sp/>Method<sp/>2]<sp/>-----------------------------------</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Another<sp/>even<sp/>better<sp/>way<sp/>is<sp/>to<sp/>draw<sp/>an<sp/>area<sp/>with<sp/>same<sp/>color,<sp/>since<sp/>most<sp/>displays<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>used<sp/>in<sp/>embedded<sp/>systems<sp/>support<sp/>setting<sp/>drawing<sp/>area<sp/>and<sp/>then<sp/>pass<sp/>a<sp/>color<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>to<sp/>fill<sp/>that<sp/>area.<sp/>This<sp/>saves<sp/>rendering<sp/>time.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//------------------------------------------------------------------</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>display_put_pixels(x,<sp/>y,<sp/>x<sp/>+<sp/>width<sp/>-<sp/>1,<sp/>y<sp/>+<sp/>height<sp/>-<sp/>1,<sp/>color);<sp/><sp/><sp/><sp/>//<sp/>Filling<sp/>an<sp/>area<sp/>with<sp/>same<sp/>color</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifdef<sp/>USE_BUFERING</highlight></codeline>
<codeline><highlight class="normal">void<sp/>my_render_cmplt_cb()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>display_fill(display_buffer,<sp/>0,<sp/>0,<sp/>HOR_RES,<sp/>VERT_RES)<sp/><sp/><sp/>//<sp/>display_fill(buffer,<sp/>x1,<sp/>y1,<sp/>x2,<sp/>y2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>display_buff_counter<sp/>=<sp/>0;<sp/>//reset<sp/>the<sp/>counter</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>my_input_read_cb<sp/>(lui_touch_input_data_t<sp/>*input)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Assuming<sp/>that<sp/>user<sp/>has<sp/>a<sp/>function<sp/>display_get_touch()<sp/>that<sp/>returns<sp/>a<sp/>`touch_data_t`<sp/>variable.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Also<sp/>assuming<sp/>that<sp/>members<sp/>of<sp/>`touch_data_t`<sp/>are:<sp/>pressed(uint8_t),<sp/>x(uint16_t),<sp/>y(uint16_t).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>touch_data_t<sp/>touch<sp/>=<sp/>display_get_touch();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>input-&gt;is_pressed<sp/>=<sp/>touch.pressed;<sp/><sp/>//<sp/>`touch.pressed`<sp/>should<sp/>be<sp/>1<sp/>if<sp/>touched,<sp/>0<sp/>if<sp/>not<sp/>touched</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(input-&gt;is_pressed<sp/>==<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input-&gt;y<sp/>=<sp/>touch.y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input-&gt;x<sp/>=<sp/>touch.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>IMPORTANT:<sp/>User<sp/>MUST<sp/>set<sp/>x<sp/>and<sp/>y<sp/>as<sp/>-1<sp/>when<sp/>display<sp/>is<sp/>NOT<sp/>touched.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input-&gt;y<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input-&gt;x<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>button_1_cb(lui_obj_t*<sp/>button_obj)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Get<sp/>the<sp/>event<sp/>of<sp/>callback</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int8_t<sp/>event<sp/>=<sp/>lui_object_get_event(button_obj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(event<sp/>==<sp/>-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(event<sp/>==<sp/>LUI_EVENT_PRESSED)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Button<sp/>is<sp/>pressed.<sp/>Do<sp/>something</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;Button<sp/>1<sp/>is<sp/>pressed&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(event<sp/>==<sp/>LUI_EVENT_RELEASED)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Button<sp/>is<sp/>released.<sp/>Do<sp/>something</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;Button<sp/>1<sp/>is<sp/>released&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Simple<sp/>Examples</highlight></codeline>
<codeline><highlight class="normal">-<sp/>Check<sp/>example<sp/>code<sp/>fragments<sp/>inside<sp/>[lame_ui.h](lame_ui.h).<sp/>Or<sp/>visit<sp/>[documentatin<sp/>page](https://abhra0897.github.io/LameUI/html/html/examples_page.html).</highlight></codeline>
<codeline><highlight class="normal">-<sp/>See<sp/>the<sp/>Quick<sp/>Start<sp/>section</highlight></codeline>
<codeline><highlight class="normal">-<sp/>go<sp/>to<sp/>the<sp/>Simulator<sp/>repo<sp/>and<sp/>see<sp/>the<sp/>example<sp/>there:<sp/>https://github.com/abhra0897/LameUI_simulation/blob/experimental/src/main.c.<sp/>That<sp/>example<sp/>has<sp/>all<sp/>the<sp/>UI<sp/>elements.<sp/>Ignore<sp/>the<sp/>parts<sp/>that<sp/>are<sp/>related<sp/>to<sp/>OpenGL.</highlight></codeline>
    </programlisting>
    <location file="README.md"/>
  </compounddef>
</doxygen>
